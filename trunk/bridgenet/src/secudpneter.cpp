// C++ implementation file "SecUdpNeter.cpp" for class SecUdpNeter generated by Poseidon for UML.
// Poseidon for UML is developed by Gentleware (http://www.gentleware.com).
// Generated with velocity template engine (http://jakarta.apache.org/velocity).

#include "myfilelog.hxx"
#include "loghelper.hxx"
#include "udpsocketexception.hxx"
#include "udpserversocket.hxx"
#include "was_api.h"
#include "udpsocket.hxx"
#include "udpbridgenet.hxx"
#include "secudpneter.hxx"

SecUdpNeter::SecUdpNeter(tUInt32 timingoutms,FileLog* filelog)
:Thread(),
_imsg_que(),
_omsg_que(),
_unacknowledged_osmg_list(),
_failed_omsg_que(),
_ever_received_imsg_list(),
_socket(NULL),
_listen_port(0),
_timingoutms(timingoutms),
_is_shutdown_requested(FALSE),
_filelog(filelog)
{
}
SecUdpNeter::SecUdpNeter(tUInt32 port,tUInt32 timingoutms,FileLog* filelog)
:Thread(),
_imsg_que(),
_omsg_que(),
_unacknowledged_osmg_list(),
_failed_omsg_que(),
_ever_received_imsg_list(),
_socket(NULL),
_listen_port(port),
_timingoutms(timingoutms),
_is_shutdown_requested(FALSE),
_filelog(filelog)
{
}
SecUdpNeter::SecUdpNeter(UdpSocket* udpsocket,tUInt32 timingoutms,FileLog* filelog)
:Thread(),
_imsg_que(),
_omsg_que(),
_unacknowledged_osmg_list(),
_failed_omsg_que(),
_ever_received_imsg_list(),
_socket(udpsocket),
_listen_port(0),
_timingoutms(timingoutms),
_is_shutdown_requested(FALSE),
_filelog(filelog)
{}
void SecUdpNeter::Shutdown(void)
{
	_is_shutdown_requested = TRUE;
}

void SecUdpNeter::SendTo(tBridgeMsg* omsg, string remote_host, tUInt32 remote_port)
{
	omsg->rhost = remote_host;
	omsg->rport = remote_port;

	_omsg_que.Push(omsg);
}


tBool SecUdpNeter::Recv(tBridgeMsg** imsg)
{
	if ((*imsg)=_imsg_que.Pop())
		return TRUE;
	else
		return FALSE;
}
tBool SecUdpNeter::AnyOMsgFailed(void) const
{
	return (!_failed_omsg_que.Empty());
}
string SecUdpNeter::PeerLocalAddress(void)
{
	UdpSocket* socket = new UdpSocket();

	string localhost = socket->PeerLocalHost();

	delete socket;

	return localhost;
}
void SecUdpNeter::Execute(Thread::Arg arg)
{
	UdpBridgeNet* bridgenet;
	tBridgeMsg* imsg;
	tBridgeMsg* omsg;
	tByte* msg;
	tUInt32 len;
	tBridgeMsg* bmsg;
	tUnacknowledgedOMsg* unacknowledgedomsg;
	tBridgeUnacknowledgedMsgListIter unacknowledgedomsglistiter;
	BridgeNet::tBridgeNetStatus res;
	tBool is_external_socket=TRUE;
	tBool isbusy;
	tUInt32 counter=0;

	LOGINFO("SecUdpNeter starting up...");

	try
	{
		if (!_socket)
		{
			is_external_socket = FALSE;

			if (_listen_port)
				_socket = new UdpServerSocket(_listen_port);
			else
				_socket = new UdpSocket();
		}
	}
	catch (UdpSocketException& e)
	{
		LOGERROR("SecUdpNeter::Execute:Failed to create the UdpSocket:"<<e.Description());
		if (_socket)
		{
			_socket->Close();
			delete _socket;
			_socket = NULL;
		}

		Shutdown();
	}

	bridgenet = new UdpBridgeNet(_filelog);

	bridgenet->SetUdpSocket(_socket);

	while (!_is_shutdown_requested)
	{
		isbusy = FALSE;

		res = bridgenet->ReceiveMsg(&imsg);

		if(res==BridgeNet::eMsgAvailable)
		{
			isbusy = TRUE;

			if (imsg->tom==E_WAS_MSG_ACKNOWLEDGE)
			{
				LOGDEBUG("SecUdpNeter::Execute:Omsg #"<<imsg->tid<<" is acknowledged from '"<<imsg->rhost<<"::"<<imsg->rport<<"'.");

				unacknowledgedomsglistiter = _unacknowledged_osmg_list.begin();

				while (unacknowledgedomsglistiter!=_unacknowledged_osmg_list.end())
				{
					unacknowledgedomsg = *unacknowledgedomsglistiter;

					if (unacknowledgedomsg->omsg->tid == imsg->tid)
					{
						ReleaseBridgeMsg(&(unacknowledgedomsg->omsg));
						delete unacknowledgedomsg;
						unacknowledgedomsg = NULL;

						_unacknowledged_osmg_list.erase(unacknowledgedomsglistiter);

						break;
					}
					else
						unacknowledgedomsglistiter++;
				}

				ReleaseBridgeMsg(&imsg);	//release the acknowledge imsg.
			}
			else
			{
				LOGDEBUG("SecUdpNeter::Execute:Received a msg #"<<imsg->tid<<" from '"<<imsg->rhost<<"::"<<imsg->rport<<"'.");

				/** acknowledge it.*/
				msg = was_write_msg(&len, E_WAS_MSG_FIRST_PART, E_WAS_MSG_ACKNOWLEDGE,imsg->tid, X_WAS_RSPC_OK,
											E_WAS_TAG_ID_NONE);
				assert(msg);
				bmsg = CreateBridgeMsg();
				bmsg->rhost = imsg->rhost;
				bmsg->rport = imsg->rport;
				bmsg->lom = len;
				bmsg->mpi = E_WAS_MSG_FIRST_PART;
				bmsg->tid = imsg->tid;
				bmsg->rspc= X_WAS_RSPC_OK;
				bmsg->msg = msg;
				bmsg->tom = E_WAS_MSG_ACKNOWLEDGE;
				bmsg->isReceived = FALSE;
				_omsg_que.Push(bmsg);

				if(IsMsgEverReceived(imsg))
				{
					LOGDEBUG("SecUdpNeter::Execute:The imsg #"<<imsg->tid<<" from "<<imsg->rhost<<"::"<<imsg->rport<<" is ever received,just abandon it.");
					ReleaseBridgeMsg(&imsg);
				}
				else
				{
					/** register it as ever received.*/
					RegisterIMsgAsEverReceived(imsg);

					/** save it.*/
					_imsg_que.Push(imsg);
				}
			}
		}

		/** send and move it to unacknowledged omsg list waiting for the acknowledge from peer.*/
		if ((omsg=_omsg_que.Pop()))
		{
			isbusy = TRUE;

			if (!bridgenet->SendBridgeMsg(omsg))
			{
				LOGWARNING("SecUdpNeter::Execute:Failed to send Omsg #"<<omsg->tid<<" at first time,just repush it for sending again.");
				_omsg_que.Push(omsg);
			}
			else 
			{
				if (omsg->tom!=E_WAS_MSG_ACKNOWLEDGE)
				{
					LOGDEBUG("SecUdpNeter::Execute:Omsg #"<<omsg->tid<<" has been sent to '"<<omsg->rhost<<"::"<<omsg->rport<<"'.");

					unacknowledgedomsg = new tUnacknowledgedOMsg;
					unacknowledgedomsg->omsg = omsg;
					unacknowledgedomsg->tick_counter=0;

					_unacknowledged_osmg_list.push_front(unacknowledgedomsg);
				}
				else
				{
					LOGDEBUG("SecUdpNeter::Execute:Acknowledge msg #"<<omsg->tid<<" has been sent to '"<<omsg->rhost<<"::"<<omsg->rport<<"'.");
					ReleaseBridgeMsg(&omsg);
				}
			}
		}

		/** Check if the sending omsg failed,then move to failed msg que or send again.*/
		if (++counter==_timingoutms/10)
		{
			counter = 0;

			/** check if any unacknowledged omsg failed,if so move to the failure que.*/
			unacknowledgedomsglistiter = _unacknowledged_osmg_list.begin();

			while (unacknowledgedomsglistiter!=_unacknowledged_osmg_list.end())
			{
				unacknowledgedomsg = *unacknowledgedomsglistiter;

				if (_timingoutms/1000 == unacknowledgedomsg->tick_counter)
				{
					LOGDEBUG("SecUdpNeter::Execute:Omsg #"<<unacknowledgedomsg->omsg->tid<<" to '"<<unacknowledgedomsg->omsg->rhost<<"::"<<unacknowledgedomsg->omsg->rport<<"' failed.");

					/** if failed, move to failure que.*/
					_failed_omsg_que.Push(unacknowledgedomsg->omsg);

					unacknowledgedomsglistiter = _unacknowledged_osmg_list.erase(unacknowledgedomsglistiter);
					delete unacknowledgedomsg;
					unacknowledgedomsg = NULL;
				}
				else
				{
					unacknowledgedomsglistiter++;

					/** send it again.*/
					bridgenet->SendBridgeMsg(unacknowledgedomsg->omsg);

					unacknowledgedomsg->tick_counter++;

					LOGDEBUG("SecUdpNeter::Execute:Omsg #"<<unacknowledgedomsg->omsg->tid<<" to '"<<unacknowledgedomsg->omsg->rhost<<"::"<<unacknowledgedomsg->omsg->rport<<"' has been resent "<<unacknowledgedomsg->tick_counter<<" times.");					
				}
			}
		}

		if (!isbusy)
			Thread::Yield();
	}

	LOGDEBUG("SecUdpNeter::Execute:Shutdown signal received.");

	if (!is_external_socket && _socket)
	{
		_socket->Close();
		delete _socket;
		_socket = NULL;
	}

	if (bridgenet)
	{
		delete bridgenet;
		bridgenet = NULL;
	}

	/** clear the msgs later.*/
	

	LOGINFO("SecUdpNeter shutdowned.");
}
tBool SecUdpNeter::IsMsgEverReceived(tBridgeMsg* imsg) const
{
	tBool ret = FALSE;

	tMsgBasicInfoListConstIter iter = _ever_received_imsg_list.begin();

	while (iter!=_ever_received_imsg_list.end())
	{
		if ((*iter)->ip.compare(imsg->rhost)==0 && (*iter)->port==imsg->rport && (*iter)->tid==imsg->tid)
		{
			ret = TRUE;
			break;
		}
		else
			iter++;
	}

	return ret;
}
void SecUdpNeter::RegisterIMsgAsEverReceived(tBridgeMsg* imsg)
{
	tMsgBasicInfo* basicinfo = new tMsgBasicInfo;

	basicinfo->ip = imsg->rhost;
	basicinfo->port = imsg->rport;
	basicinfo->tid = imsg->tid;

	_ever_received_imsg_list.push_front(basicinfo);
}